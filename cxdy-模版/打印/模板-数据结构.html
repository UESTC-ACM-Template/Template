<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>数据结构</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <!-- TOC -->
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><br>
- <a href="#pb_ds">pb_ds</a><br>
- <a href="#rope">rope</a><br>
- <a href="#bitset">bitset</a><br>
- <a href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组</a><br>
- <a href="#%E8%8E%AB%E9%98%9F">莫队</a><br>
- <a href="#%E4%B8%80%E8%88%AC%E8%8E%AB%E9%98%9F">一般莫队</a><br>
- <a href="#%E5%B8%A6%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E7%9A%84%E8%8E%AB%E9%98%9F">带单点修改的莫队</a><br>
- <a href="#%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F">树上莫队</a><br>
- <a href="#kdtree">KDtree</a><br>
- <a href="#%E5%A5%97%E8%B7%AF">套路</a><br>
- <a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%89%AB%E6%8F%8F%E7%BA%BF">线段树-扫描线</a><br>
- <a href="#hash%E8%A1%A8">HASH表</a><br>
- <a href="#splay">Splay</a><br>
- <a href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86">树链剖分</a><br>
- <a href="#lct">LCT</a><br>
- <a href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86">可持久化并查集</a></li>
</ul>
<!-- /TOC -->
<h1 id="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">数据结构</h1>
<h3 id="pbds">pb_ds</h3>
<pre><code><div>//优先队列
#include&lt;ext/pb_ds/priority_queue.hpp&gt;
using namespace __gnu_pbds;
__gnu_pbds::priority_queue&lt;type, cmp, tag&gt; pq;
//tyge为变量类型，如int，char
//cmp为比较函数,如less&lt;int&gt;,greater&lt;int&gt;
//tag是堆类型，有配对堆（pairing_heap_tag）、二叉堆（binary_heap_tag）、二项堆（binomial_heap_tag）、
冗余计数二项堆（rc_binomial_heap_tag）、经改良的斐波那契堆（thin_heap_tag）
//支持合并操作a.join(b)   修改值 a.modify(it,x),it为迭代器
//一般使用pairing_heap



//平衡树
#include&lt;ext/pb_ds/assoc_container.hpp&gt;
using namespace __gnu_pbds;
tree&lt;key, value, cmp, tag, tree_order_statistics_node_update&gt; bbt;
//key为变量类型，如int，char
//value为键值类型，同map、、若使用set，该处为null_type或null_mapped_type
//cmp为比较函数,如less(从小到大),greater
//tag是堆类型，有红黑树（rb_tree_tag）、伸展树（splay_tree_tag）和排序向量树（oov_tree_tag）
//求kth（find_by_order）返回的是迭代器，求rank（order_of_key）返回的是值，两者都是从0开始计算的。

</div></code></pre>
<h3 id="rope">rope</h3>
<p>1）运算符：rope支持operator += -= + - &lt; ==</p>
<p>2）输入输出：可以用 &lt;&lt; 运算符由输入输出流读入或输出。</p>
<p>3）长度 / 大小：调用length()，size()都可以哦</p>
<p>4）插入 / 添加等：</p>
<pre><code><div>push_back(x);//在末尾添加x

insert(pos, x); //在pos插入x，自然支持整个char数组的一次插入

erase(pos, x); //从pos开始删除x个

copy(pos, len, x); //从pos开始到pos+len为止用x代替

replace(pos, x); //从pos开始换成x

substr(pos, x); //提取pos开始x个

at(x) / [x]; //访问第x个元素
</div></code></pre>
<p>头文件：</p>
<pre><code><div>#include&lt;ext/rope&gt;
</div></code></pre>
<p>调用命名空间：</p>
<pre><code><div>using namespace __gnu_cxx;
</div></code></pre>
<h3 id="bitset">bitset</h3>
<p>bitset的第i位是从右向左数的第i位</p>
<pre><code><div>bitset&lt;n&gt; b;
b有n位，每位都为0

bitset&lt;n&gt; b(u);
b是unsigned long型u的一个副本(可用来输出2进制)

bitset&lt;n&gt; b(s);
b是string对象s中含有的位串的副本

bitset&lt;n&gt; b(s, pos, n);
b是s中从位置pos开始的n个位的副本

b._Find_first()
返回b中第一个1的下标

b._Find_next(pos)
返回b中从pos往后第一个1的下标

b.any()b中是否存在置为1的二进制位？

b.none()b中不存在置为1的二进制位吗？

b.count()b中置为1的二进制位的个数

b.size()b中二进制位的个数

b[pos]访问b中在pos处的二进制位

b.test(pos)b中在pos处的二进制位是否为1？

b.set()把b中所有二进制位都置为1

b.set(pos)把b中在pos处的二进制位置为1

b.reset()把b中所有二进制位都置为0

b.reset(pos)把b中在pos处的二进制位置为0

b.flip()把b中所有二进制位逐位取反

b.flip(pos)把b中在pos处的二进制位取反

b.to_ulong()用b中同样的二进制位返回一个unsigned long值

os &lt;&lt; b 把b中的位集输出到os流
</div></code></pre>
<h3 id="stl%e7%9a%84%e4%ba%8c%e5%88%86">STL的二分</h3>
<p>函数upper_bound()返回的在前闭后开区间查找的关键字的上界，如一个数组number序列1, 2, 2, 4.upper_bound(2)后，返回的位置是3（下标）也就是4所在的位置, 同样，如果插入元素大于数组中全部元素，返回的是last。（注意：此时数组下标越界！！）<br>
返回查找元素的最后一个可安插位置，也就是“元素值 &gt; 查找值”的第一个元素的位置</p>
<p>函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置</p>
<p>###CDQ分治<br>
先处理左区间，然后处理左区间对右区间的影响，然后处理右区间</p>
<p>###整体二分<br>
当询问的答案具有二分性质<br>
修改对答案的影响相互独立<br>
可离线时<br>
可二分答案，把询问和操作分到左右两个区间，然后分治</p>
<h3 id="st%e8%a1%a8">ST表</h3>
<pre><code><div>const int maxn = 1e5 + 5;
int a[maxn];
int st[maxn][22];
int lg[maxn];

void st_init(int len) {
 for (int i = len - 1; i &gt;= 0; --i) {
     st[i][0] = a[i + 1];
     for (int j = 1; i + (1 &lt;&lt; j) &lt;= len; ++j)
         st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);
 }
}
int Max(int l, int r) {
 int k = lg[r - l + 1];
 return max(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);
}


for (int i = 2; i &lt; maxn; ++i) lg[i] = lg[i &gt;&gt; 1] + 1;
</div></code></pre>
<h3 id="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84">树状数组</h3>
<pre><code><div>int lowbit(int t) {
    return t &amp; (-t);
}
</div></code></pre>
<h3 id="%e8%8e%ab%e9%98%9f">莫队</h3>
<p><strong>T了大胆的调块的大小</strong><br>
####一般莫队<br>
满足离线询问区间答案, 区间变化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>更新答案<br>
块大小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>, 复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">n\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord mathdefault">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span></p>
<pre><code><div>//左端点块排序，再右端点排序
bool cmp(const node &amp;a, const node &amp;b) {
    if(pos[a.l] == pos[b.l]) return (pos[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r; //按左端点的块的奇偶性分类排序,减小常数
    else return pos[a.l] &lt; pos[b.l];
}
</div></code></pre>
<p>####带单点修改的莫队<br>
满足离线询问区间答案, 区间变化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>更新答案, 存在单点修改<br>
块大小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mfrac><mn>2</mn><mn>3</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">n^ {\frac{2}{3}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9540200000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>, 复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mfrac><mn>5</mn><mn>3</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">n^ {\frac{5}{3}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9540200000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code><div>// 本代码是单点修改的求区间不同数个数
const int maxn = 1e5 + 5;
const int mod = 1e9 + 7;
struct node {
    int l, r, t, id;// t 询问时修改操作的时间轴
} f[maxn];
struct cnode {
    int pre, now, id;// 原值 新值 修改位置
} g[maxn];
int pos[maxn], ans[maxn], bsize;
int a[maxn], b[maxn * 10], res, numf, numg;

//左端点块排序，再右端块排序， 最后时间轴排序
bool cmp(const node &amp;a, const node &amp;b) {
    if(pos[a.l] == pos[b.l]) {
        if(pos[a.r] == pos[b.r]) return a.t &lt; b.t;
        else return a.r &lt; b.r;
    } else return pos[a.l] &lt; pos[b.l];
}

void add(int x) {
    if(++b[x] == 1) res++;
}

void del(int x) {
    if(--b[x] == 0) res--;
}

void addt(int k, int i) {
    if(g[k].id &gt;= f[i].l &amp;&amp; g[k].id &lt;= f[i].r) {
        del(g[k].pre);
        add(g[k].now);
    }
    a[g[k].id] = g[k].now;
}

void delt(int k, int i) {
    if(g[k].id &gt;= f[i].l &amp;&amp; g[k].id &lt;= f[i].r) {
        del(g[k].now);
        add(g[k].pre);
    }
    a[g[k].id] = g[k].pre;
}

int main() {
    int n, m, i, j, k, l, r, t;
    char c;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    bsize = pow(n, 2.0 / 3) + 1;
    for(i = j = k = 1; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
        pos[i] = j;
        if(k++ == bsize) {
            k = 1;
            j++;
        }
    }
    numf = numg = 0;
    for(i = 1; i &lt;= m; i++) {
        scanf(&quot; %c%d%d&quot;, &amp;c, &amp;l, &amp;r);
        if(c == 'Q') f[++numf] = node{l, r, numg, numf};
        else {
            g[++numg] = cnode{a[l], r, l};
            a[l] = r;
        }
    }
    sort(f + 1, f + numf + 1, cmp);
    l = 1;
    r = 0;
    t = numg;
    for(i = 1, res = 0; i &lt;= numf; i++) {
        while(r &lt; f[i].r) add(a[++r]);
        while(l &gt; f[i].l) add(a[--l]);
        while(r &gt; f[i].r) del(a[r--]);
        while(l &lt; f[i].l) del(a[l++]);
        while(t &lt; f[i].t) addt(++t, i);
        while(t &gt; f[i].t) delt(t--, i);
        ans[f[i].id] = res;
    }
    for(i = 1; i &lt;= numf; i++) printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}
</div></code></pre>
<h4 id="%e6%a0%91%e4%b8%8a%e8%8e%ab%e9%98%9f">树上莫队</h4>
<p>询问子树:<br>
按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span>序记录每个点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">st[u], ed[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>, 仅在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">ed[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>时加点, 子树询问就转化为一维的区间询问了, 做法同一般莫队<br>
询问路径:<br>
按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span>序记录每个点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">st[u], ed[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">st[u], ed[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>时都加点, 对于路径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>−</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u - v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>, 假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">st[u] &lt; st[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>, 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的祖先, 则转化为区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">st[u] - st[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>, 否则转化为区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">ed[u] - st[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>并额外补上一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span></span></span></span>的值(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span></span></span></span>没有计算到)<br>
可以发现, 这样只有路径上的点访问了奇数次, 采用奇数次上偶数次减即可<br>
带单点修改:<br>
仿照普通莫队的修改加一维即可</p>
<pre><code><div>该代码求路径上不同的数的个数
struct node {
    int l, r, ex, id;
    bool operator &lt;(const node &amp;b) const {
        if(l / bsize == b.l / bsize) return r &lt; b.r;
        else return l &lt; b.l;
    }
} q[maxn];
vector&lt;int&gt; g[maxn];
int depth = 0, bn = 0, b[maxn];
int f[maxn], dfn[maxn], st[maxn], ed[maxn];
// 树的点值 新序列表示的树上的点的标号 区间不同的数的答案记录
int a[maxn], ck[maxn], d_t[maxn], ans[maxn], tot, res;
// 点的更新次数
bool vis[maxn];
unordered_map&lt;int, int&gt; qt;

int get_id(int x) {
    if(!qt[x]) qt[x] = ++tot;
    return qt[x];
}

void add(int x) {
    if(++d_t[x] == 1) res++;
}

void del(int x) {
    if(--d_t[x] == 0) res--;
}

void update(int k) {
    if(vis[k]) del(a[k]);
    else add(a[k]);
    vis[k] ^= 1;
}

void dfs(int u, int fa) {
    int tmp = ++depth;
    b[++bn] = tmp;
    st[u] = bn;
    ck[bn] = u;
    f[tmp] = u;
    dfn[u] = bn;
    for (auto v : g[u]) {
        if (v == fa) continue;
        dfs(v, u);
        b[++bn] = tmp;
        ed[v] = bn;
        ck[bn] = v;
    }
}

int sd[maxn][20];
int lg[maxn];
void st_init() {
    for (int i = 2; i &lt; maxn; ++i) lg[i] = lg[i &gt;&gt; 1] + 1;
    for (int i = bn; i &gt;= 1; --i) {
        sd[i][0] = b[i];
        for (int j = 1; i + (1 &lt;&lt; j) - 1 &lt;= bn; ++j)
            sd[i][j] = min(sd[i][j - 1], sd[i + (1 &lt;&lt; (j - 1))][j - 1]);
    }
}
int rmq(int l, int r) {
    int k = lg[r - l + 1];
    return min(sd[l][k], sd[r - (1 &lt;&lt; k) + 1][k]);
}

int lca(int a, int b) {
    if(a == b) return a;
    if (dfn[a] &gt; dfn[b]) swap(a, b);
    int k = rmq(dfn[a], dfn[b]);
    return f[k];
}

int main() {
    int u, v, i, n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(i = 1; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
        a[i] = get_id(a[i]);
    }
    for(i = 1; i &lt; n; i++) {
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, 0);
    st_init();
    for(i = 0; i &lt; m; i++) {
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        if(st[u] &gt; st[v]) swap(u, v);
        if(lca(u, v) == u) q[i] = node{st[u], st[v], 0, i};
        else q[i] = node{ed[u], st[v], lca(u, v), i};
    }
    sort(q, q + m);
    int l = 1, r = 0;
    for(i = 0; i &lt; m; i++) {
        while(r &lt; q[i].r) update(ck[++r]);
        while(l &gt; q[i].l) update(ck[--l]);
        while(r &gt; q[i].r) update(ck[r--]);
        while(l &lt; q[i].l) update(ck[l++]);
        if(q[i].ex) add(a[q[i].ex]);
        ans[q[i].id] = res;
        if(q[i].ex) del(a[q[i].ex]);
    }
    for(i = 0; i &lt; m; i++) printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}
</div></code></pre>
<h3 id="kdtree">KDtree</h3>
<p>KDtree支持动态插点, 如果插入操作太多, 可以考虑插入一定次数后重新建树<br>
支持询问矩形区间内的答案, 支持询问点的最近最远点<br>
####套路<br>
树上询问一个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的子树内的答案, 一维表示dfs序, 一维表示从根结点开始的深度, 建树, 那么询问就转化为矩形区间询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>d</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[st[u], ed[u]][deep[u], deep[u] + k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>(st, ed分别为dfs时开始访问这个点时和结束访问这个点时的dfs序, deep表示深度)<br>
对一维序列询问区间内出现一次的数的最值:<br>
一维为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数下标, 一维为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数上次出现位置, 一维为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数下次出现位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, pre[i], nxt[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>, 询问转化为区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r][0, l - 1][r + 1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>最值</p>
<pre><code><div>const int max_d = 2;//维度
static int f_id;//优先判断维度
int nxt[max_d], root, tot; // 根,树中点的总数
// 每次build后需及时更新root,插入和查询操作都是从根结点开始
// 根结点并不一定是1
LL ans;
int pu[max_d];
struct node {
    int u[max_d], p_min[max_d], p_max[max_d], l, r;
    bool operator &lt; (const node &amp;b) const {
        for(int i = 0, j = f_id; i &lt; max_d; i++) {
            if(u[j] != b.u[j]) return u[j] &lt; b.u[j];
            if(++j == max_d) j = 0;
        }
        return true;
    }
    void clear() {
        l = r = 0;
    }
} f[maxn];
void init(int n) {
    tot = n;
    for(int i = 0; i + 1 &lt; max_d; i++) nxt[i] = i + 1;
    nxt[max_d - 1] = 0;
    for(int i = 0; i &lt;= n; i++) f[i].clear();
}
inline void updata(int x, int y) {
    for(int i = 0; i &lt; max_d; i++) {
        f[x].p_min[i] = min(f[x].p_min[i], f[y].p_min[i]);
        f[x].p_max[i] = max(f[x].p_max[i], f[y].p_max[i]);
    }
}
int build(int l, int r, int id) {
    f_id = id;
    int mid = (l + r) &gt;&gt; 1;
    nth_element(f + l + 1, f + mid + 1, f + r + 1);
    for(int i = 0; i &lt; max_d; i++) f[mid].p_min[i] = f[mid].p_max[i] = f[mid].u[i];
    if(l &lt; mid) {
        f[mid].l = build(l, mid - 1, nxt[id]);
        updata(mid, f[mid].l);
    } else f[mid].l = 0;
    if(mid &lt; r) {
        f[mid].r = build(mid + 1, r, nxt[id]);
        updata(mid, f[mid].r);
    } else f[mid].r = 0;
    return mid;
}
// 加点
int add_point(int u[]) {
    f[++tot].clear();
    memcpy(f[tot].u, u, sizeof(int) * max_d);
    memcpy(f[tot].p_min, u, sizeof(int) * max_d);
    memcpy(f[tot].p_max, u, sizeof(int) * max_d);
    return tot;
}
// 插点
void insert(int t, int id) {
    if(pu[id] &lt; f[t].u[id]) {
        if(f[t].l) insert(f[t].l, nxt[id]);
        else f[t].l = add_point(pu);
        updata(t, f[t].l);
    } else {
        if(f[t].r) insert(f[t].r, nxt[id]);
        else f[t].r = add_point(pu);
        updata(t, f[t].r);
    }
}
inline LL sqr(LL x) {
    return x * x;
}
// 求距离函数,这里是欧式距离,可以根据题目换成曼哈顿距离
// 求曼哈顿距离 只需将下面两个函数中的sqr改成abs即可
inline LL dist(int k) {
    LL s = 0;
    for(int i = 0; i &lt; max_d; i++) s += sqr(f[k].u[i] - pu[i]);
    return s;
}
// 求根为k的子树中的点到pu点的距离的下界
inline LL dist_min(int k) {
    LL s = 0;
    for(int i = 0; i &lt; max_d; i++) {
        if(f[k].p_min[i] &gt; pu[i]) s += sqr(f[k].p_min[i] - pu[i]);
        if(f[k].p_max[i] &lt; pu[i]) s += sqr(f[k].p_max[i] - pu[i]);
    }
    return s;
}
// 询问复杂度最坏是sqrt(n)
void query(int t) {
    LL d = dist(t), dl = inf, dr = inf;
    ans = min(ans, d);
    if(f[t].l) dl = dist_min(f[t].l);
    if(f[t].r) dr = dist_min(f[t].r);
    if(dl &lt; dr) {
        if(dl &lt; ans) query(f[t].l);
        if(dr &lt; ans) query(f[t].r);
    } else {
        if(dr &lt; ans) query(f[t].r);
        if(dl &lt; ans) query(f[t].l);
    }
}
// 区间询问
void query(int t, int x1, int y1, int x2, int y2) {
    if(x1 &gt; f[t].p_max[0] || x2 &lt; f[t].p_min[0] || y1 &gt; f[t].p_max[1] || y2 &lt; f[t].p_min[1]) return;
    if(x1 &lt;= f[t].p_min[0] &amp;&amp; f[t].p_max[0] &lt;= x2 &amp;&amp; y1 &lt;= f[t].p_min[1] &amp;&amp; f[t].p_max[1] &lt;= y2) {
        ans = min(ans, f[t].min_v); //更新区间内答案
        return;
    }
    if(x1 &lt;= f[t].u[0] &amp;&amp; f[t].u[0] &lt;= x2 &amp;&amp; y1 &lt;= f[t].u[1] &amp;&amp; f[t].u[1] &lt;= y2) ans = min(ans, f[t].v); //更新单点答案
    if(f[t].l) query(f[t].l, x1, y1, x2, y2);
    if(f[t].r) query(f[t].r, x1, y1, x2, y2);
}
</div></code></pre>
<h3 id="%e7%ba%bf%e6%ae%b5%e6%a0%91-%e6%89%ab%e6%8f%8f%e7%ba%bf">线段树-扫描线</h3>
<pre><code><div>struct edge {
    int l, r, h, d;
    bool operator&lt;(const edge &amp;a)const {
        return h &lt; a.h;
    }
};
vector&lt;edge&gt;f;
vector&lt;int&gt;v;
int sum[NN &lt;&lt; 2][15];
int mark[NN &lt;&lt; 2];
int n, m, k;

int ff(int x) {
    int l, r, mid;
    l = 0;
    r = k;
    while(l &lt;= r) {
        mid = (l + r) &gt;&gt; 1;
        if(v[mid] == x) return mid;
        if(v[mid] &lt; x) l = mid + 1;
        else r = mid - 1;
    }
    return l;
}

void build(int root, int l, int r) {
    mark[root] = 0;
    memset(sum[root], 0, sizeof(sum[root]));
    sum[root][0] = v[r + 1] - v[l];
    if(l == r) return;
    int mid;
    mid = (l + r) &gt;&gt; 1;
    build(root &lt;&lt; 1, l, mid);
    build(root &lt;&lt; 1 | 1, mid + 1, r);
}

void pushup(int root, int l, int r) { //m重覆盖
    int i;
    memset(sum[root], 0, sizeof(sum[root]));
    if(mark[root] &gt; m) sum[root][m + 1] = v[r + 1] - v[l];
    else if(l == r) sum[root][mark[root]] = v[r + 1] - v[l];
    else if(l != r) {
        for(i = mark[root]; i &lt;= m + 1; i++) sum[root][i] += sum[root &lt;&lt; 1][i - mark[root]] + sum[root &lt;&lt; 1 | 1][i - mark[root]];
        for(i = m - mark[root] + 2; i &lt;= m + 1; i++) sum[root][m + 1] += sum[root &lt;&lt; 1][i] + sum[root &lt;&lt; 1 | 1][i];
    }
}

void update(int l, int r, int root, int d, int ll, int rr) {
    if(l &lt;= ll &amp;&amp; r &gt;= rr) {
        mark[root] += d;
        pushup(root, ll, rr);
        return;
    }
    int mid;
    mid = (ll + rr) &gt;&gt; 1;
    if(l &lt;= mid) update(l, r, root &lt;&lt; 1, d, ll, mid);
    if(r &gt; mid) update(l, r, root &lt;&lt; 1 | 1, d, mid + 1, rr);
    pushup(root, ll, rr);
}

long long getans() { //fg = 0
    int l, r, i, tail;
    long long ans;
    k = 0;
    ans = 0;
    v.push_back(MAX);
    sort(f.begin(), f.end());
    sort(v.begin(), v.end());
    tail = v.size();
    for(i = 1; i &lt; tail; i++) {
        if(v[i] != v[i - 1]) v[++k] = v[i];
    }
    build(1, 0, k);
    for(i = 0; i &lt; tail - 1; i++) {
        l = ff(f[i].l);
        r = ff(f[i].r) - 1;
        if(l &lt;= r) update(l, r, 1, f[i].d, 0, k);
        ans += (long long) sum[1][m] * (f[i + 1].h - f[i].h);
    }
    return ans;
}

int main() {
//    f.push_back(edge{x1,x2,y1,1});//以x轴加边
//    f.push_back(edge{x1,x2,y2,-1});
//    v.push_back(x1); //用于离散化
//    v.push_back(x2);
    return 0;
}
</div></code></pre>
<h3 id="hash%e8%a1%a8">HASH表</h3>
<pre><code><div>template&lt;typename T, typename U&gt;
struct HashMap {
    static const int M = 333331;
    int chk[M], cn;
    int q[M], qn;
    vector&lt;T&gt; a;
    vector&lt;U&gt; b;
    int fst[M], m;
    vector&lt;int&gt; nxt;
    HashMap() {
        memset(fst, -1, sizeof fst);
        cn++;
    }
    void clear() {
        for (int i = 0; i &lt; qn; i++) fst[q[i]] = -1;
        cn++;
        qn = m = 0;
        a.clear(), b.clear(), nxt.clear();
    }
    U&amp; operator[](T x) {
        int r = (x % M + M) % M;
        for (int e = fst[r]; ~e; e = nxt[e]) {
            if (a[e] == x) {
                return b[e];
            }
        }
        if (chk[r] != cn) {
            chk[r] = cn;
            q[qn++] = r;
        }
        a.push_back(x), b.push_back(U());
        nxt.push_back(fst[r]), fst[r] = m++;
        return b.back();
    }
    bool count(T x) {
        int r = (x % M + M) % M;
        for (int e = fst[r]; ~e; e = nxt[e]) {
            if (a[e] == x) {
                return 1;
            }
        }
        return 0;
    }
};
</div></code></pre>
<h3 id="splay">Splay</h3>
<p>带删除查询版</p>
<pre><code><div>#define MAXN 1000000
int ch[MAXN][2], f[MAXN], size[MAXN], cnt[MAXN], key[MAXN];
int sz, root;
inline void clear(int x) {
    ch[x][0] = ch[x][1] = f[x] = size[x] = cnt[x] = key[x] = 0;
}
inline bool get(int x) {
    return ch[f[x]][1] == x;
}
inline void update(int x) {
    if (x) {
        size[x] = cnt[x];
        if (ch[x][0]) size[x] += size[ch[x][0]];
        if (ch[x][1]) size[x] += size[ch[x][1]];
    }
}
inline void rotate(int x) {
    int old = f[x], oldf = f[old], whichx = get(x);
    ch[old][whichx] = ch[x][whichx ^ 1];
    f[ch[old][whichx]] = old;
    ch[x][whichx ^ 1] = old;
    f[old] = x;
    f[x] = oldf;
    if (oldf)
        ch[oldf][ch[oldf][1] == old] = x;
    update(old);
    update(x);
}
inline void splay(int x) {
    for (int fa; fa = f[x]; rotate(x))
        if (f[fa])
            rotate((get(x) == get(fa)) ? fa : x);
    root = x;
}
// 插入x
inline void insert(int x) {
    if (root == 0) {
        sz++;
        ch[sz][0] = ch[sz][1] = f[sz] = 0;
        root = sz;
        size[sz] = cnt[sz] = 1;
        key[sz] = x;
        return;
    }
    int now = root, fa = 0;
    while(1) {
        if (x == key[now]) {
            cnt[now]++;
            update(now);
            update(fa);
            splay(now);
            break;
        }
        fa = now;
        now = ch[now][key[now] &lt; x];
        if (now == 0) {
            sz++;
            ch[sz][0] = ch[sz][1] = 0;
            f[sz] = fa;
            size[sz] = cnt[sz] = 1;
            ch[fa][key[fa] &lt; x] = sz;
            key[sz] = x;
            update(fa);
            splay(sz);
            break;
        }
    }
}
// 查询x的最小排名
inline int find(int x) {
    int now = root, ans = 0;
    while(1) {
        if (x &lt; key[now])
            now = ch[now][0];
        else {
            ans += (ch[now][0] ? size[ch[now][0]] : 0);
            if (x == key[now]) {
                splay(now);
                return ans + 1;
            }
            ans += cnt[now];
            now = ch[now][1];
        }
    }
}
// 查询排名为x的数
inline int findx(int x) {
    int now = root;
    while(1) {
        if (ch[now][0] &amp;&amp; x &lt;= size[ch[now][0]])
            now = ch[now][0];
        else {
            int temp = (ch[now][0] ? size[ch[now][0]] : 0) + cnt[now];
            if (x &lt;= temp) return key[now];
            x -= temp;
            now = ch[now][1];
        }
    }
}
inline int pre() {
    int now = ch[root][0];
    while (ch[now][1]) now = ch[now][1];
    return now;
}
inline int next() {
    int now = ch[root][1];
    while (ch[now][0]) now = ch[now][0];
    return now;
}
// 删除x,有多个仅删除一个
inline void del(int x) {
    find(x);
    if (cnt[root] &gt; 1) {
        cnt[root]--;
        update(root);
        return;
    }
    if (!ch[root][0] &amp;&amp; !ch[root][1]) {
        clear(root);
        root = 0;
        return;
    }
    if (!ch[root][0]) {
        int oldroot = root;
        root = ch[root][1];
        f[root] = 0;
        clear(oldroot);
        return;
    } else if (!ch[root][1]) {
        int oldroot = root;
        root = ch[root][0];
        f[root] = 0;
        clear(oldroot);
        return;
    }
    int leftbig = pre(), oldroot = root;
    splay(leftbig);
    ch[root][1] = ch[oldroot][1];
    f[ch[oldroot][1]] = root;
    clear(oldroot);
    update(root);
}
// 寻找x的前驱(最大的小于x的数)
inline int find_pre(int x) {
    insert(x);
    int w = key[pre()];
    del(x);
    return w;
}
// 寻找x的后继(最小的大于x的数)
inline int find_next(int x) {
    insert(x);
    int w = key[next()];
    del(x);
    return w;
}
</div></code></pre>
<p>带lazy标记区间修改版</p>
<pre><code><div>const int INF = 2e9 + 1e8;
const int maxn = 1e6 + 10;
struct SplayTree {
    struct Node {
        int son[2], big, val, lazy, sz;
        bool rev;
        void init(int _val) {
            val = big = _val;
            sz = 1;
            lazy = son[0] = son[1] = rev = 0;
        }
    } T[maxn];
    // 初始数组为a
    int root, fa[maxn], a[maxn];
    void pushup(int i) {
        T[i].big = T[i].val, T[i].sz = 1;
        if(T[i].son[0]) {
            T[i].big = max(T[i].big, T[T[i].son[0]].big);
            T[i].sz += T[T[i].son[0]].sz;
        }
        if(T[i].son[1]) {
            T[i].big = max(T[i].big, T[T[i].son[1]].big);
            T[i].sz += T[T[i].son[1]].sz;
        }
    }
    void pushdown(int i) {
        if(i == 0) return;
        if(T[i].lazy) {
            for(int k = 0; k &lt; 2; k++) {
                if(T[i].son[k]) {
                    T[T[i].son[k]].lazy += T[i].lazy;
                    T[T[i].son[k]].val += T[i].lazy;
                    T[T[i].son[k]].big += T[i].lazy;
                }
            }
            T[i].lazy = 0;
        }
        if(T[i].rev) {
            for(int k = 0; k &lt; 2; k++)
                if(T[i].son[k]) T[T[i].son[k]].rev ^= 1;
            swap(T[i].son[0], T[i].son[1]);
            T[i].rev = 0;
        }
    }
    /**  旋转操作
     * 传入x，旋转x与x的父亲这两个节点；
     */
    void rotate(int x, int d) {
        int y = fa[x], z = fa[y];
        T[y].son[!d] = T[x].son[d], fa[T[x].son[d]] = y;
        T[x].son[d] = y, fa[y] = x;
        T[z].son[T[z].son[1] == y] = x, fa[x] = z;
        pushup(y);
    }
    void splay(int x, int goal) {
        if(x == goal) return;
        while (fa[x] != goal) {
            int y = fa[x], z = fa[y];
            pushdown(z), pushdown(y), pushdown(x);
            int dirx = (T[y].son[0] == x), diry = (T[z].son[0] == y);
            if(z == goal) rotate(x, dirx);
            else {
                if(dirx == diry) rotate(y, diry);
                else rotate(x, dirx);
                rotate(x, diry);
            }
        }
        pushup(x);
        if(goal == 0) root = x;
    }
    /**
     * select(pos) 返回第pos+1个元素；
     */
    int Select(int pos) {
        int u = root;
        pushdown(u);
        while(T[T[u].son[0]].sz != pos) {
            if(pos &lt; T[T[u].son[0]].sz) u = T[u].son[0];
            else {
                pos = pos - (1 + T[T[u].son[0]].sz);
                u = T[u].son[1];
            }
            pushdown(u);
        }
        return u;
    }
    //区间[l,r] 加 val
    void update(int l, int r, int val) {
        int x = Select(l - 1), y = Select(r + 1);
        splay(x, 0);
        splay(y, x);
        T[T[y].son[0]].val += val;
        T[T[y].son[0]].big += val;
        T[T[y].son[0]].lazy += val;
    }
    // 翻转[l,r]区间
    void turn(int l, int r) {
        int x = Select(l - 1), y = Select(r + 1);
        splay(x, 0);
        splay(y, x);
        T[T[y].son[0]].rev ^= 1;
    }
    // 求区间[l,r]的最大值
    int query(int l, int r) {
        int x = Select(l - 1), y = Select(r + 1);
        splay(x, 0);
        splay(y, x);
        return T[T[y].son[0]].big;
    }
    int build(int L, int R) {
        if(L &gt; R) return 0;
        if(L == R) return L;
        int mid = (L + R) &gt;&gt; 1, sL, sR;
        T[mid].son[0] = sL = build(L, mid - 1);
        T[mid].son[1] = sR = build(mid + 1, R);
        fa[sL] = fa[sR] = mid;
        pushup(mid);
        return mid;
    }
    void init(int n) {
        T[1].init(-INF), T[n + 2].init(-INF);
        // 初始化splay树
        for(int i = 2; i &lt;= n + 1; i++) T[i].init(a[i - 1]);
        root = build(1, n + 2), fa[root] = 0;
        fa[0] = 0, T[0].son[1] = root, T[0].sz = 0;
    }
} re;
</div></code></pre>
<h3 id="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86">树链剖分</h3>
<p>//将一个树划分为若干个不相交的路径, 使每个结点仅在一条路径上.<br>
//满足: 从结点u到v最多经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\log{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span>条路径, 以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\log{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span>条不在路径上的边.<br>
//采用启发式划分, 即某结点选择与子树中结点数最大的儿子划分为一条路径.<br>
//时间复杂度: 用其他数据结构来维护每条链, 复杂度为所选数据结构乘以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\log{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span>.<br>
//用两次dfs来进行树链剖分. 对于每一个结点v, 找到它的size最大的子结点u. 如果u不存在, 那么给v分配一条新的路径, 否则v就延续u所属的路径.<br>
//查询两个结点u, v之间的路径是, 首先判断它们是否属于同一路径. 如果不是, 选择所属路径顶端结点h的深度较大的结点, 不妨假设是v, 查询v到h, 并令v = father[h]继续查询, 直至u, v属于同一路径. 最后在这条路径上查询并返回.</p>
<pre><code><div>/*
sz[u]: 结点u的子树的结点数量
fa[u]: 结点u的父结点
dep[u]: 结点u在树中的深度
son[u]: 结点u的重儿子
dfn[u]: 树中结点u的dfs序,按先重链后轻链的顺序
id[i]: dfs序为i的结点
top[u]: 结点u所在链的第一个结点
*/
vector&lt;int&gt; g[maxn];
int sz[maxn], fa[maxn], dep[maxn], son[maxn];
int top[maxn], dfn[maxn];
int cnt = 0;

void dfs1(int u, int father) {
    dep[u] = dep[father] + 1;
    fa[u] = father;
    sz[u] = 1;
    son[u] = -1;
    for(auto v : g[u]) {
        if(v == father) continue;
		dfs1(v, u);
        sz[u] += sz[v];
        if(son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v;
    }
}

void dfs2(int u, int t) {
    top[u] = t;
    dfn[u] = ++cnt;
    if(son[u] == -1) return;
    dfs2(son[u], t);
    for(auto v : g[u]) {
        if(v == son[u] || v == fa[u]) continue;
        dfs2(v, v);
    }
}
void query(int u, int v) {
    int x = top[u], y = top[v];
    while(x != y) {
        int &amp;w = dep[x] &gt; dep[y] ? u : v;
        int &amp;z = dep[x] &gt; dep[y] ? x : y;
        //query(dfn[z] --&gt;  dfn[w])
        w = fa[z];
        z = top[w];
    }
    if(dfn[u] &gt; dfn[v]) swap(u, v);
    //query(dfn[u] --&gt; dfn[v])
}

dfs1(1, 0);
dfs2(1, 1);
</div></code></pre>
<h3 id="lct">LCT</h3>
<p>//LCT = 树链剖分 + Splay<br>
//功能: 支持对树的分割, 合并, 对某个点到它的根的路径的某些操作, 以及对某个点的子树进行的某些操作. (同时维护树的形态)<br>
/*定义:<br>
如果刚刚执行了对某个点的Access操作, 则称一个点被访问过;<br>
结点v的子树中, 如果最后被访问访问的结点在子树w中, 这里w是v的儿子, 那么称w是v的Preferred Child. 如果最后被访问的结点是v本身, 则v没有Preferred Child.<br>
每个结点到它的Preferred Child的边称作Preferred Edge.<br>
由Preferred Edge连接成的不可再延伸的路径称为Preferred Path.<br>
这棵树就被划分成若干条Preferred Path, 对于每一条Preferred Path, 用其结点的深度做关键字, 用Splay Tree树维护它, 称这棵树为 Auxiliary Tree.<br>
用 Path Parent 来记录每棵 Auxiliary Tree 对应的 Preferred Path 中的最高点的父亲结点, 如果这个 Preferred Path 的最高点就是根结点, 那么令这棵 Auxiliary Tree 的 Path Parent 为 null.<br>
Link-Cut Trees 就是将要维护的森林中的每棵树 T 表示为若干个 Auxiliary Tree, 并通过 Path Parent 将这些 Auxiliary Tree 连接起来的数据结构.<br>
操作:<br>
Access(x): 使结点x到根结点的路径成为新的Preferred Path.<br>
FindRoot(x): 返回结点x所在树的根结点.<br>
Link(x, y): 使结点x成为结点y的新儿子. 其中x是一棵树的根结点, 且x和y属于两棵不同的子树.<br>
Cut(x): 删除x与其父亲结点间的边.<br>
LCA(x, y): 返回x, y的最近公共祖先(x, y在同一颗树中)</p>
<pre><code><div>//根不确定
const int NUM = 100010;
#define LC(x) ch[x][0]
#define RC(x) ch[x][1]
#define DIR(x) (x == RC(fa[x]))
#define IsRoot(x) (!fa[x] || (x != LC(fa[x]) &amp;&amp; x != RC(fa[x])))
struct LCT {
    int ch[NUM][2], fa[NUM], size;
    int stk[NUM], top;
    bool rev[NUM];
    int sz[NUM];
    int tag[NUM];
    LL ans[NUM];
    inline void push_up(int x) {
    }
    inline void Rev(int x) {
        rev[x] ^= 1, swap(LC(x), RC(x));
    }
    inline void push_down(int x) {
        if(tag[x]) {
            if(LC(x)) sz[LC(x)] += tag[x], tag[LC(x)] += tag[x];
            if(RC(x)) sz[RC(x)] += tag[x], tag[RC(x)] += tag[x];
            tag[x] = 0;
        }
        if(rev[x]) {
            Rev(x);
            rev[LC(x)] ^= 1, rev[RC(x)] ^= 1;
            rev[x] = 0;
        }
    }
    inline void Change(int x, int y, int d) {
        ch[x][d] = y;
        fa[y] = x;
    }
    inline int New() {
        size++;
        LC(size) = RC(size) = fa[size] = 0;
        sz[size] = 1;
        tag[size] = 0;
        return size;
    }
    inline void Rot(int x) {
        int y = fa[x], z = fa[y], d = DIR(x);
        if(!IsRoot(y)) Change(z, x, DIR(y));
        else fa[x] = z;
        Change(y, ch[x][!d], d);
        Change(x, y, !d);
        fa[0] = LC(0) = RC(0) = 0;
        push_up(y);
    }
    void push_path(int x) {
        for(top = 0; !IsRoot(x); x = fa[x]) stk[++top] = x;
        stk[++top] = x;
        for(int i = top; i; --i) push_down(stk[i]);
    }
    void Splay(int x) {
        push_path(x);
        int y, z;
        while(!IsRoot(x)) {
            y = fa[x], z = fa[y];
            if(IsRoot(y)) {
                Rot(x);
                break;
            }
            Rot(DIR(x) == DIR(y) ? y : x), Rot(x);
        }
        push_up(x);
    }
    int Access(int x) {
        int p;
        for(p = 0; x; p = x, x = fa[x]) {
            Splay(x), RC(x) = p, push_up(x);
        }
        return p;
    }
    void MakeRoot(int x) {
        Access(x), Splay(x);
        rev[x] = 1;
        push_down(x);
    }
    void Link(int x, int y) {
        MakeRoot(x);
        fa[x] = y;
        Access(x);
        Splay(x);
        if(LC(x)) {
            ++sz[LC(x)];
            ++tag[LC(x)];
        }
    }
    void Cut(int x, int y) {
        MakeRoot(y);
        Access(x);
        Splay(x);
        LC(x) = fa[y] = 0;
        push_up(x);
    }
    int FindRoot(int x) {
        Access(x);
        Splay(x);
        while(LC(x)) x = LC(x);
        return x;
    }
    int LCA(int x, int y) {
        Access(x);
        return Access(y);
    }
} lct;

//根确定
const int NUM = 200010;
#define LC(x) ch[x][0]
#define RC(x) ch[x][1]
#define DIR(x) (x == RC(fa[x]))
#define IsRoot(x) (!fa[x] || (x != LC(fa[x]) &amp;&amp; x != RC(fa[x])))
struct LCT {
    int ch[NUM][2], fa[NUM], size;
    inline void Change(int x, int y, int d) {
        ch[x][d] = y;
        fa[y] = x;
    }
    inline int New() {
        size++;
        LC(size) = RC(size) = fa[size] = 0;
        return size;
    }
    void init(int n) {
        size = 0;
        for(int i = 1; i &lt;= n; ++i) New();
    }
    inline void Rot(int x) {
        int y = fa[x], z = fa[y], d = DIR(x);
        if(!IsRoot(y)) Change(z, x, DIR(y));
        else fa[x] = z;
        Change(y, ch[x][!d], d);
        Change(x, y, !d);
        fa[0] = LC(0) = RC(0) = 0;
    }

    void Splay(int x) {
        int y, z;
        while(!IsRoot(x)) {
            y = fa[x], z = fa[y];
            if(IsRoot(y)) {
                Rot(x);
                break;
            }
            Rot(DIR(x) == DIR(y) ? y : x), Rot(x);
        }
    }
    int Access(int x) {
        int p;
        for(p = 0; x; p = x, x = fa[x]) {
            Splay(x), RC(x) = p;
        }
        return p;
    }

    void Link(int x, int y) {
        Access(x);
        Splay(y);
        fa[x] = y;
    }
    void Cut(int x) {
        Splay(x);
        if(!fa[x]) {
            fa[ch[x][0]] = 0;
            ch[x][0] = 0;
        } else {
            fa[ch[x][0]] = fa[x];
            ch[x][0] = 0;
        }
        fa[x] = 0;
    }
    int FindRoot(int x) {
        int u = x;
        while(fa[x]) x = fa[x];
        while(ch[x][0]) x = ch[x][0];
        Access(u);
        return x;
    }
} lct;
</div></code></pre>
<h3 id="%e5%8f%af%e6%8c%81%e4%b9%85%e5%8c%96%e5%b9%b6%e6%9f%a5%e9%9b%86">可持久化并查集</h3>
<pre><code><div>int n, m, sz;
int root[200005], ls[2000005], rs[2000005], v[2000005], deep[2000005];
void build(int &amp;k, int l, int r) {
    if(!k)k = ++sz;
    if(l == r) {
        v[k] = l;
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(ls[k], l, mid);
    build(rs[k], mid + 1, r);
}
void modify(int l, int r, int x, int &amp;y, int pos, int val) {
    y = ++sz;
    if(l == r) {
        v[y] = val;
        deep[y] = deep[x];
        return;
    }
    ls[y] = ls[x];
    rs[y] = rs[x];
    int mid = (l + r) &gt;&gt; 1;
    if(pos &lt;= mid)
        modify(l, mid, ls[x], ls[y], pos, val);
    else modify(mid + 1, r, rs[x], rs[y], pos, val);
}
int query(int k, int l, int r, int pos) {
    if(l == r)return k;
    int mid = (l + r) &gt;&gt; 1;
    if(pos &lt;= mid)return query(ls[k], l, mid, pos);
    else return query(rs[k], mid + 1, r, pos);
}
void add(int k, int l, int r, int pos) {
    if(l == r) {
        deep[k]++;
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    if(pos &lt;= mid)add(ls[k], l, mid, pos);
    else add(rs[k], mid + 1, r, pos);
}
int find(int k, int x) {
    int p = query(k, 1, n, x);
    if(x == v[p])return p;
    return find(k, v[p]);
}
int main() {
    int t;
    In(t);
    while(t--) {
        In(n), In(m);
        build(root[0], 1, n);
        int f, a, b;
        for(int i = 1; i &lt;= m; i++) {
            In(f);
            if(f == 1) {
                root[i] = root[i - 1];
                In(a), In(b);
                int p = find(root[i], a), q = find(root[i], b);
                if(v[p] == v[q])continue;
                if(deep[p] &gt; deep[q])swap(p, q);
                modify(1, n, root[i - 1], root[i], v[p], v[q]);
                if(deep[p] == deep[q])add(root[i], 1, n, v[q]);
            }
            if(f == 2) {
                root[i] = root[i - 1];
                In(a), In(b);
                int p = find(root[i], a), q = find(root[i], b);
                if(v[p] != v[q]) printf(&quot;NO\n&quot;);
                else printf(&quot;YES\n&quot;);
            }
        }
    }
    return 0;
}
</div></code></pre>

    </body>
    </html>